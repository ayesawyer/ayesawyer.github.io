<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="操作系统,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="对于操作系统相关基础知识进行复习和整理。">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统基础">
<meta property="og:url" content="http://yoursite.com/2019/07/09/操作系统基础/index.html">
<meta property="og:site_name" content="Aye&#39;s house">
<meta property="og:description" content="对于操作系统相关基础知识进行复习和整理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/1.jpg">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/2.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/3.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/4.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/5.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/6.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/7.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/8.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/9.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/10.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/11.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/12.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/13.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/14.png">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/2.jpg">
<meta property="og:image" content="http://yoursite.com/2019/07/09/操作系统基础/3.jpg">
<meta property="og:updated_time" content="2019-08-10T03:28:18.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统基础">
<meta name="twitter:description" content="对于操作系统相关基础知识进行复习和整理。">
<meta name="twitter:image" content="http://yoursite.com/2019/07/09/操作系统基础/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/09/操作系统基础/">





  <title>操作系统基础 | Aye's house</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aye's house</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/操作系统基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ayesawyer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aye's house">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T21:52:58+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/07/09/操作系统基础/" class="leancloud_visitors" data-flag-title="操作系统基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对于操作系统相关基础知识进行复习和整理。</p>
<a id="more"></a>
<p><strong>主要参考自：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">CyC2018/CS-Notes</a></strong></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="A-基本特征"><a href="#A-基本特征" class="headerlink" title="A.基本特征"></a>A.基本特征</h3><h4 id="（1）并发与并行"><a href="#（1）并发与并行" class="headerlink" title="（1）并发与并行"></a>（1）并发与并行</h4><ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，强调的是时间片的轮换，交替执行，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<p><img src="/2019/07/09/操作系统基础/1.png" alt=""></p>
<blockquote>
<p><a href="https://blog.csdn.net/worn_xiao/article/details/82498408" target="_blank" rel="noopener">【操作系统】并发与并行</a></p>
</blockquote>
<h4 id="（2）共享"><a href="#（2）共享" class="headerlink" title="（2）共享"></a>（2）共享</h4><ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>有两种共享方式：互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li>
</ul>
<h4 id="（3）虚拟"><a href="#（3）虚拟" class="headerlink" title="（3）虚拟"></a>（3）虚拟</h4><ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体。</li>
<li>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
<h4 id="（4）异步"><a href="#（4）异步" class="headerlink" title="（4）异步"></a>（4）异步</h4><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h3 id="B-基本功能"><a href="#B-基本功能" class="headerlink" title="B.基本功能"></a>B.基本功能</h3><h4 id="（1）进程管理"><a href="#（1）进程管理" class="headerlink" title="（1）进程管理"></a>（1）进程管理</h4><p>进程控制（进程控制块PCB）、进程同步、进程通信、死锁处理、处理机调度等</p>
<p>进程和线程——</p>
<ul>
<li>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）。</li>
<li>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）。</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/leesf456/p/5413517.html" target="_blank" rel="noopener">【操作系统】进程管理（二）</a></p>
</blockquote>
<h4 id="（2）内存管理"><a href="#（2）内存管理" class="headerlink" title="（2）内存管理"></a>（2）内存管理</h4><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h4 id="（3）文件管理"><a href="#（3）文件管理" class="headerlink" title="（3）文件管理"></a>（3）文件管理</h4><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h4 id="（4）设备管理"><a href="#（4）设备管理" class="headerlink" title="（4）设备管理"></a>（4）设备管理</h4><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h3 id="C-系统调用"><a href="#C-系统调用" class="headerlink" title="C.系统调用"></a>C.系统调用</h3><p>如果一个进程在用户态需要使用内核态的功能，就需要进行系统调用。Linux的系统调用主要有以下函数——</p>
<p>|—|—|<br>| Task | Commands |<br>| 进程控制 | fork(); exit(); wait(); |<br>| 进程通信| pipe(); shmget(); mmap(); |<br>| 文件操作| open(); read(); write(); |<br>| 设备操作| ioctl(); read(); write(); |<br>| 信息维护| getpid(); alarm(); sleep(); |<br>| 安全| chmod(); umask(); chown(); |</p>
<h3 id="D-内核-大内核和微内核"><a href="#D-内核-大内核和微内核" class="headerlink" title="D.内核(大内核和微内核)"></a>D.内核(大内核和微内核)</h3><h4 id="（1）内核"><a href="#（1）内核" class="headerlink" title="（1）内核"></a>（1）内核</h4><p>操作系统内核是指大多数操作系统的核心部分。它由操作系统中用于管理存储器、文件、外设和系统资源的那些部分组成。内核，是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。</p>
<p>linux内核提供的主要功能包括——</p>
<ul>
<li>进程调度</li>
<li>内存管理</li>
<li>驱动模型</li>
</ul>
<h4 id="（2）大内核"><a href="#（2）大内核" class="headerlink" title="（2）大内核"></a>（2）大内核</h4><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。</p>
<h4 id="（3）微内核"><a href="#（3）微内核" class="headerlink" title="（3）微内核"></a>（3）微内核</h4><p>由于操作系统的复杂性，将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<p><img src="/2019/07/09/操作系统基础/1.jpg" alt=""></p>
<h3 id="E-中断"><a href="#E-中断" class="headerlink" title="E.中断"></a>E.中断</h3><p>中断分类如下——</p>
<p>1、外中断：由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<p>2、异常：由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<p>3、陷入：在用户程序中使用系统调用。</p>
<h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h2><h3 id="A-进程与线程"><a href="#A-进程与线程" class="headerlink" title="A.进程与线程"></a>A.进程与线程</h3><h4 id="（1）进程"><a href="#（1）进程" class="headerlink" title="（1）进程"></a>（1）进程</h4><p>进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h4 id="（2）线程"><a href="#（2）线程" class="headerlink" title="（2）线程"></a>（2）线程</h4><p>线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。</p>
<p><em>举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</em></p>
<h4 id="（3）线程和进程的区别"><a href="#（3）线程和进程的区别" class="headerlink" title="（3）线程和进程的区别"></a>（3）线程和进程的区别</h4><blockquote>
<p><strong>资源：</strong>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。<br><strong>调度：</strong>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。<br><strong>系统开销：</strong>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。<br><strong>通信：</strong>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p>
</blockquote>
<h3 id="B-进程状态切换"><a href="#B-进程状态切换" class="headerlink" title="B.进程状态切换"></a>B.进程状态切换</h3><blockquote>
<p>就绪状态（ready）：等待被调度<br>运行状态（running）<br>阻塞状态（waiting）：等待资源</p>
</blockquote>
<p><img src="/2019/07/09/操作系统基础/2.png" alt=""></p>
<p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</p>
<h3 id="C-进程调度算法"><a href="#C-进程调度算法" class="headerlink" title="C.进程调度算法"></a>C.进程调度算法</h3><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h4 id="（1）批处理系统"><a href="#（1）批处理系统" class="headerlink" title="（1）批处理系统"></a>（1）批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h4 id="（2）交互式系统"><a href="#（2）交互式系统" class="headerlink" title="（2）交互式系统"></a>（2）交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<h4 id="（3）实时系统"><a href="#（3）实时系统" class="headerlink" title="（3）实时系统"></a>（3）实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h3 id="D-进程同步"><a href="#D-进程同步" class="headerlink" title="D.进程同步"></a>D.进程同步</h3><h4 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h4><ol>
<li><strong>临界区：</strong>对临界资源进行访问的那段代码，为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</li>
<li><strong>同步：</strong>多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li><strong>互斥：</strong>多个进程在同一时刻只有一个进程能进入临界区。</li>
<li><strong>信号量：</strong>一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</li>
</ol>
<blockquote>
<p>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；<br>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p>
</blockquote>
<h4 id="（2）经典同步问题"><a href="#（2）经典同步问题" class="headerlink" title="（2）经典同步问题"></a>（2）经典同步问题</h4><h5 id="A-消费者-生产者问题"><a href="#A-消费者-生产者问题" class="headerlink" title="A.消费者-生产者问题"></a>A.消费者-生产者问题</h5><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p><strong>1、使用信号量实现生产者-消费者问题</strong></p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<pre><code>#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&amp;empty);
        down(&amp;mutex);
        insert_item(item);
        up(&amp;mutex);
        up(&amp;full);
    }
}

void consumer() {
    while(TRUE) {
        down(&amp;full);
        down(&amp;mutex);
        int item = remove_item();
        consume_item(item);
        up(&amp;mutex);
        up(&amp;empty);
    }
}
</code></pre><p><strong>2、使用管程实现生产者-消费者问题</strong></p>
<p>c 语言不支持管程。管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><img src="/2019/07/09/操作系统基础/3.png" alt=""></p>
<h5 id="B-读者-写者问题"><a href="#B-读者-写者问题" class="headerlink" title="B.读者-写者问题"></a>B.读者-写者问题</h5><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code>typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&amp;count_mutex);
        count++;
        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);
        read();
        down(&amp;count_mutex);
        count--;
        if(count == 0) up(&amp;data_mutex);
        up(&amp;count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&amp;data_mutex);
        write();
        up(&amp;data_mutex);
    }
}
</code></pre><h5 id="C-哲学家进餐问题"><a href="#C-哲学家进餐问题" class="headerlink" title="C.哲学家进餐问题"></a>C.哲学家进餐问题</h5><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。为了防止死锁的发生，可以设置两个条件：必须同时拿起左右两根筷子；只有在两个邻居都没有进餐的情况下才允许进餐。</p>
<p><img src="/2019/07/09/操作系统基础/4.png" alt=""></p>
<h3 id="E-进程通信"><a href="#E-进程通信" class="headerlink" title="E.进程通信"></a>E.进程通信</h3><blockquote>
<p>进程同步：控制多个进程按一定顺序执行；<br>进程通信：进程间传输信息。</p>
</blockquote>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p><strong>接下来列举一些操作系统中常用的进程间通信机制。</strong></p>
<h4 id="（1）管道"><a href="#（1）管道" class="headerlink" title="（1）管道"></a>（1）管道</h4><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。它具有以下限制：只支持半双工通信（单向交替传输）；只能在父子进程或者兄弟进程中使用。</p>
<pre><code>#include &lt;unistd.h&gt;
int pipe(int fd[2]);
</code></pre><h4 id="（2）FIFO（命名管道）"><a href="#（2）FIFO（命名管道）" class="headerlink" title="（2）FIFO（命名管道）"></a>（2）FIFO（命名管道）</h4><p>去除了管道只能在父子进程中使用的限制。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<h4 id="（3）消息队列"><a href="#（3）消息队列" class="headerlink" title="（3）消息队列"></a>（3）消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h4 id="（4）信号量"><a href="#（4）信号量" class="headerlink" title="（4）信号量"></a>（4）信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h4 id="（5）共享存储"><a href="#（5）共享存储" class="headerlink" title="（5）共享存储"></a>（5）共享存储</h4><blockquote>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。<br>需要使用信号量用来同步对共享存储的访问。<br>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
</blockquote>
<h4 id="（6）套接字"><a href="#（6）套接字" class="headerlink" title="（6）套接字"></a>（6）套接字</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h2><h3 id="A-发生死锁的4个必要条件"><a href="#A-发生死锁的4个必要条件" class="headerlink" title="A.发生死锁的4个必要条件"></a>A.发生死锁的4个必要条件</h3><blockquote>
<p>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。<br>占有和等待：已经得到了某个资源的进程可以再请求新的资源。<br>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。<br>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p>
</blockquote>
<h3 id="B-死锁的处理方法"><a href="#B-死锁的处理方法" class="headerlink" title="B.死锁的处理方法"></a>B.死锁的处理方法</h3><ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h4 id="（1）鸵鸟策略"><a href="#（1）鸵鸟策略" class="headerlink" title="（1）鸵鸟策略"></a>（1）鸵鸟策略</h4><blockquote>
<p>把头埋在沙子里，假装根本没发生问题。<br>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
</blockquote>
<h4 id="（2）死锁检测与死锁恢复"><a href="#（2）死锁检测与死锁恢复" class="headerlink" title="（2）死锁检测与死锁恢复"></a>（2）死锁检测与死锁恢复</h4><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h5 id="A-每种类型一个资源的死锁检测"><a href="#A-每种类型一个资源的死锁检测" class="headerlink" title="A.每种类型一个资源的死锁检测"></a>A.每种类型一个资源的死锁检测</h5><p><img src="/2019/07/09/操作系统基础/5.png" alt=""></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p><strong>每种类型一个资源的死锁检测算法</strong>是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h5 id="B-每种类型多个资源的死锁检测"><a href="#B-每种类型多个资源的死锁检测" class="headerlink" title="B.每种类型多个资源的死锁检测"></a>B.每种类型多个资源的死锁检测</h5><p><img src="/2019/07/09/操作系统基础/6.png" alt=""></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p><strong>算法总结如下：</strong>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h5 id="C-死锁恢复"><a href="#C-死锁恢复" class="headerlink" title="C.死锁恢复"></a>C.死锁恢复</h5><blockquote>
<p>利用抢占恢复——如果条件允许，可以临时将某个资源从它的占有者转移到另一个进程。<br>利用回滚恢复——周期性的进行<strong>检查点</strong>检查, 记录进程状态、资源状态等信息; 死锁发生时，恢复到上一个检查点的状态。<br>通过杀死进程恢复——先 ps -ef(aux也行) 找进程（可以添加|grep 帮助查找），然后kill 这个进程的PID号。</p>
</blockquote>
<h4 id="（3）死锁预防"><a href="#（3）死锁预防" class="headerlink" title="（3）死锁预防"></a>（3）死锁预防</h4><p>在程序运行之前预防发生死锁。通过设置某些限制条件，去破坏死锁的四个必要条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。有以下方法。</p>
<blockquote>
<p>破坏互斥条件——互斥条件是设备的固有属性所决定的，一般情况下不能改变，但也不是绝对。例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。<br>破坏占有和等待条件——一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。<br>破坏不可抢占条件——即当某进程新的资源未满足时，释放已占有的资源。<br>破坏环路等待——给资源统一编号，进程只能按编号顺序来请求资源，该方法比较低效。</p>
</blockquote>
<h4 id="（4）死锁避免"><a href="#（4）死锁避免" class="headerlink" title="（4）死锁避免"></a>（4）死锁避免</h4><p>在程序运行时避免发生死锁。在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁。两种常用的死锁避免算法：</p>
<ul>
<li>进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程。</li>
<li>资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配(如<strong>银行家算法</strong>)。</li>
</ul>
<h5 id="A-安全状态"><a href="#A-安全状态" class="headerlink" title="A.安全状态"></a>A.安全状态</h5><p>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。举例如下——</p>
<p><img src="/2019/07/09/操作系统基础/7.png" alt=""></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p><em>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</em></p>
<h5 id="B-单个资源的银行家算法"><a href="#B-单个资源的银行家算法" class="headerlink" title="B.单个资源的银行家算法"></a>B.单个资源的银行家算法</h5><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="/2019/07/09/操作系统基础/8.png" alt=""></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h5 id="C-多个资源的银行家算法"><a href="#C-多个资源的银行家算法" class="headerlink" title="C.多个资源的银行家算法"></a>C.多个资源的银行家算法</h5><p><img src="/2019/07/09/操作系统基础/9.png" alt=""></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p><strong>检查一个状态是否安全的算法如下：</strong></p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4.内存管理"></a>4.内存管理</h2><h3 id="A-虚拟内存"><a href="#A-虚拟内存" class="headerlink" title="A.虚拟内存"></a>A.虚拟内存</h3><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<p><img src="/2019/07/09/操作系统基础/10.png" alt=""></p>
<h3 id="B-分页系统地址映射"><a href="#B-分页系统地址映射" class="headerlink" title="B.分页系统地址映射"></a>B.分页系统地址映射</h3><p><strong>内存管理单元（MMU）</strong>管理着地址空间和物理内存的转换，其中的<strong>页表（Page table）</strong>存储着<strong>页（程序地址空间）</strong>和<strong>页框（物理内存空间）</strong>的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p><img src="/2019/07/09/操作系统基础/11.png" alt=""></p>
<p>上图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<h3 id="C-页面置换算法"><a href="#C-页面置换算法" class="headerlink" title="C.页面置换算法"></a>C.页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生<strong>缺页中断</strong>从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p><strong>页面置换算法</strong>和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p><strong>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</strong></p>
<p>下面简单介绍几种常用的页面置换算法。</p>
<h4 id="（1）最佳置换算法-OPT-Optimal-replacement-algorithm"><a href="#（1）最佳置换算法-OPT-Optimal-replacement-algorithm" class="headerlink" title="（1）最佳置换算法(OPT, Optimal replacement algorithm)"></a>（1）最佳置换算法(OPT, Optimal replacement algorithm)</h4><p>所选择的<strong>被换出的页面将是最长时间内不再被访问</strong>，通常可以保证获得最低的缺页率。</p>
<p>是一种<strong>理论上的算法</strong>，当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。虽然这个算法不可能实现，但是最佳页面置换算法可以用于对可实现算法的性能进行衡量比较。</p>
<p><em>举例</em>：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<pre><code>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h4 id="（2）最近最久未使用算法-LRU-Least-Recently-Used"><a href="#（2）最近最久未使用算法-LRU-Least-Recently-Used" class="headerlink" title="（2）最近最久未使用算法(LRU, Least Recently Used)"></a>（2）最近最久未使用算法(LRU, Least Recently Used)</h4><p>LRU 将<strong>最近最久未使用的页面换出</strong>。</p>
<p>LRU算法是经常采用的页面置换算法，并被认为是相当好的，但是存在如何实现它的问题。LRU算法需要实际硬件的支持。其问题是怎么确定最后使用时间的顺序，对此有以下可行的办法——</p>
<ol>
<li><p>计数器。最简单的情况是使每个页表项对应一个使用时间字段，并给CPU增加一个逻辑时钟或计数器。每次存储访问，该时钟都加1。每当访问一个页面时，时钟寄存器的内容就被复制到相应页表项的使用时间字段中。这样我们就可以始终保留着每个页面最后访问的“时间”。在置换页面时，选择该时间值最小的页面。这样做，不仅要查页表，而且当页表改变时（因CPU调度）要维护这个页表中的时间，还要考虑到时钟值溢出的问题。</p>
</li>
<li><p>栈。用一个栈保留页号。每当访问一个页面时，就把它从栈中取出放在栈顶上。这样一来，栈顶总是放有目前使用最多的页，而栈底放着目前最少使用的页。由于要从栈的中间移走一项，所以要用具有头尾指针的双向链连起来。在最坏的情况下，移走一页并把它放在栈顶上需要改动6个指针。每次修改都要有开销，但需要置换哪个页面却可直接得到，用不着查找，因为尾指针指向栈底，其中有被置换页。</p>
</li>
</ol>
<ol start="3">
<li>在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU <strong>代价很高</strong>。如下图示例——</li>
</ol>
<p><img src="/2019/07/09/操作系统基础/12.png" alt=""></p>
<p>因实现LRU算法必须有大量硬件支持，还需要一定的软件开销。所以实际实现的都是一种简单有效的LRU近似算法（如接下来介绍的NRU）。</p>
<h4 id="（3）最近未使用算法-NRU-Not-Recently-Used"><a href="#（3）最近未使用算法-NRU-Not-Recently-Used" class="headerlink" title="（3）最近未使用算法(NRU, Not Recently Used)"></a>（3）最近未使用算法(NRU, Not Recently Used)</h4><p><em>概述：它在存储分块表的每一表项中增加一个引用位，操作系统定期地将它们置为0。当某一页被访问时，由硬件将该位置1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0后还未使用过。就可把该位是0的页淘汰出去，因为在之前最近一段时间里它未被访问过。</em></p>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h4 id="（4）先进先出置换算法-FIFO-First-In-First-Out"><a href="#（4）先进先出置换算法-FIFO-First-In-First-Out" class="headerlink" title="（4）先进先出置换算法(FIFO, First In First Out)"></a>（4）先进先出置换算法(FIFO, First In First Out)</h4><blockquote>
<p>总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。</p>
</blockquote>
<blockquote>
<p>建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。</p>
</blockquote>
<blockquote>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。<em>(这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。)</em></p>
</blockquote>
<h4 id="（5）第二次机会算法"><a href="#（5）第二次机会算法" class="headerlink" title="（5）第二次机会算法"></a>（5）第二次机会算法</h4><p><strong>对FIFO的改进算法，避免把经常使用的页面置换出去。</strong></p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<p>第二次机会算法可视为一个<strong>环形队列</strong>。用一个指针指示哪一页是下面要淘汰的。当需要一个存储块时，指针就前进，直至找到访问位是0的页。随着指针的前进，把访问位就清为0。<strong>在最坏的情况下</strong>，所有的访问位都是1，指针要通过整个队列一周，每个页都给第二次机会。这时就退化成FIFO算法了。</p>
<h4 id="（6）clock置换算法"><a href="#（6）clock置换算法" class="headerlink" title="（6）clock置换算法"></a>（6）clock置换算法</h4><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<p><img src="/2019/07/09/操作系统基础/13.png" alt=""></p>
<h3 id="D-分段"><a href="#D-分段" class="headerlink" title="D.分段"></a>D.分段</h3><blockquote>
<p><a href="https://www.cnblogs.com/mdumpling/p/8494806.html" target="_blank" rel="noopener">操作系统-分段机制</a></p>
</blockquote>
<h4 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h4><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致<strong>覆盖问题</strong>（每一张表都有自己的起始地址，但是当变量很多的时候，符号表需要的空间可能会超过程序正文的起始地址，这个时候就会把源程序的表的地址覆盖掉）的出现。</p>
<p><img src="/2019/07/09/操作系统基础/14.png" alt=""></p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<h4 id="（2）分段的作用"><a href="#（2）分段的作用" class="headerlink" title="（2）分段的作用"></a>（2）分段的作用</h4><p><em>在x86的体系结构中分段内存管理是必选的，而分页管理则是可选的。</em></p>
<blockquote>
<p><strong>1、解决编译问题</strong>： 前面提到过在编译时地址覆盖的问题，可以通过分段来解决，从而简化编译程序。<br><strong>2、重新编译</strong>： 因为不同类型的数据在不同的段中，但其中一个段进行修改后，就不需要所有的段都重新进行编译。<br><strong>3、内存共享</strong>： 对内存分段，可以很容易把其中的代码段或数据段共享给其他程序，分页中因为数据代码混合在一个页面中，所以不便于共享。<br><strong>4、安全性</strong>： 将内存分为不同的段之后，因为不同段的内容类型不同，所以他们能进行的操作也不同，比如代码段的内容被加载后就不应该允许写的操作，因为这样会改变程序的行为。而在分页系统中，因为一个页不是一个逻辑实体，代码和数据可能混合在一起，无法进行安全上的控制。<br><strong>5、动态链接</strong>： 动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段(目标程序)调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。<br><strong>6、保持兼容性</strong></p>
</blockquote>
<h3 id="E-段页式"><a href="#E-段页式" class="headerlink" title="E.段页式"></a>E.段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h3 id="F-分页与分段的比较"><a href="#F-分页与分段的比较" class="headerlink" title="F.分页与分段的比较"></a>F.分页与分段的比较</h3><blockquote>
<p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p>
</blockquote>
<blockquote>
<p>地址空间的维度：分页是一维地址空间，分段是二维的。</p>
</blockquote>
<blockquote>
<p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p>
</blockquote>
<blockquote>
<p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
</blockquote>
<h2 id="5-设备管理"><a href="#5-设备管理" class="headerlink" title="5.设备管理"></a>5.设备管理</h2><h3 id="A-磁盘调度算法"><a href="#A-磁盘调度算法" class="headerlink" title="A.磁盘调度算法"></a>A.<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98" target="_blank" rel="noopener">磁盘</a>调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h4 id="（1）先来先服务-FCFS-First-Come-First-Served"><a href="#（1）先来先服务-FCFS-First-Come-First-Served" class="headerlink" title="（1）先来先服务(FCFS, First Come First Served)"></a>（1）先来先服务(FCFS, First Come First Served)</h4><p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h4 id="（2）最短寻道时间优先-SSTF-Shortest-Seek-Time-First"><a href="#（2）最短寻道时间优先-SSTF-Shortest-Seek-Time-First" class="headerlink" title="（2）最短寻道时间优先(SSTF, Shortest Seek Time First)"></a>（2）最短寻道时间优先(SSTF, Shortest Seek Time First)</h4><p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<h4 id="（3）电梯算法-SCAN"><a href="#（3）电梯算法-SCAN" class="headerlink" title="（3）电梯算法(SCAN)"></a>（3）电梯算法(SCAN)</h4><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h2><h3 id="A-编译系统"><a href="#A-编译系统" class="headerlink" title="A.编译系统"></a>A.编译系统</h3><p><img src="/2019/07/09/操作系统基础/2.jpg" alt=""></p>
<blockquote>
<p>预处理阶段：处理以 # 开头的预处理命令；<br>编译阶段：翻译成汇编文件；<br>汇编阶段：将汇编文件翻译成可重定位目标文件；<br>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</p>
</blockquote>
<h3 id="B-静态链接"><a href="#B-静态链接" class="headerlink" title="B.静态链接"></a>B.静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<h3 id="C-目标文件"><a href="#C-目标文件" class="headerlink" title="C.目标文件"></a>C.目标文件</h3><blockquote>
<p>可执行目标文件：可以直接在内存中执行；<br>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件;<br>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</p>
</blockquote>
<h3 id="D-动态链接"><a href="#D-动态链接" class="headerlink" title="D.动态链接"></a>D.动态链接</h3><p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<p><img src="/2019/07/09/操作系统基础/3.jpg" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/08/漏洞分析——ASX-to-MP3-Converter本地代码执行漏洞/" rel="next" title="漏洞分析——ASX to MP3 Converter本地代码执行漏洞">
                <i class="fa fa-chevron-left"></i> 漏洞分析——ASX to MP3 Converter本地代码执行漏洞
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/10/一些面试容易问的知识点—Android+Java/" rel="prev" title="一些面试容易问的知识点—Android+Java">
                一些面试容易问的知识点—Android+Java <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="ayesawyer">
          <p class="site-author-name" itemprop="name">ayesawyer</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">96</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ayesawyer" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://luo-double-kua.github.io/" title="隔壁xxx的小窝" target="_blank">隔壁xxx的小窝</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述"><span class="nav-number">1.</span> <span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-基本特征"><span class="nav-number">1.1.</span> <span class="nav-text">A.基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）并发与并行"><span class="nav-number">1.1.1.</span> <span class="nav-text">（1）并发与并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）共享"><span class="nav-number">1.1.2.</span> <span class="nav-text">（2）共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）虚拟"><span class="nav-number">1.1.3.</span> <span class="nav-text">（3）虚拟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）异步"><span class="nav-number">1.1.4.</span> <span class="nav-text">（4）异步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-基本功能"><span class="nav-number">1.2.</span> <span class="nav-text">B.基本功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）进程管理"><span class="nav-number">1.2.1.</span> <span class="nav-text">（1）进程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）内存管理"><span class="nav-number">1.2.2.</span> <span class="nav-text">（2）内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）文件管理"><span class="nav-number">1.2.3.</span> <span class="nav-text">（3）文件管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）设备管理"><span class="nav-number">1.2.4.</span> <span class="nav-text">（4）设备管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-系统调用"><span class="nav-number">1.3.</span> <span class="nav-text">C.系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-内核-大内核和微内核"><span class="nav-number">1.4.</span> <span class="nav-text">D.内核(大内核和微内核)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）内核"><span class="nav-number">1.4.1.</span> <span class="nav-text">（1）内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）大内核"><span class="nav-number">1.4.2.</span> <span class="nav-text">（2）大内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）微内核"><span class="nav-number">1.4.3.</span> <span class="nav-text">（3）微内核</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E-中断"><span class="nav-number">1.5.</span> <span class="nav-text">E.中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-进程管理"><span class="nav-number">2.</span> <span class="nav-text">2.进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-进程与线程"><span class="nav-number">2.1.</span> <span class="nav-text">A.进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）进程"><span class="nav-number">2.1.1.</span> <span class="nav-text">（1）进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）线程"><span class="nav-number">2.1.2.</span> <span class="nav-text">（2）线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）线程和进程的区别"><span class="nav-number">2.1.3.</span> <span class="nav-text">（3）线程和进程的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-进程状态切换"><span class="nav-number">2.2.</span> <span class="nav-text">B.进程状态切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-进程调度算法"><span class="nav-number">2.3.</span> <span class="nav-text">C.进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）批处理系统"><span class="nav-number">2.3.1.</span> <span class="nav-text">（1）批处理系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）交互式系统"><span class="nav-number">2.3.2.</span> <span class="nav-text">（2）交互式系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）实时系统"><span class="nav-number">2.3.3.</span> <span class="nav-text">（3）实时系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-进程同步"><span class="nav-number">2.4.</span> <span class="nav-text">D.进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）基本概念"><span class="nav-number">2.4.1.</span> <span class="nav-text">（1）基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）经典同步问题"><span class="nav-number">2.4.2.</span> <span class="nav-text">（2）经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-消费者-生产者问题"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">A.消费者-生产者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-读者-写者问题"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">B.读者-写者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-哲学家进餐问题"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">C.哲学家进餐问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E-进程通信"><span class="nav-number">2.5.</span> <span class="nav-text">E.进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）管道"><span class="nav-number">2.5.1.</span> <span class="nav-text">（1）管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）FIFO（命名管道）"><span class="nav-number">2.5.2.</span> <span class="nav-text">（2）FIFO（命名管道）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）消息队列"><span class="nav-number">2.5.3.</span> <span class="nav-text">（3）消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）信号量"><span class="nav-number">2.5.4.</span> <span class="nav-text">（4）信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）共享存储"><span class="nav-number">2.5.5.</span> <span class="nav-text">（5）共享存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（6）套接字"><span class="nav-number">2.5.6.</span> <span class="nav-text">（6）套接字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-死锁"><span class="nav-number">3.</span> <span class="nav-text">3.死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-发生死锁的4个必要条件"><span class="nav-number">3.1.</span> <span class="nav-text">A.发生死锁的4个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-死锁的处理方法"><span class="nav-number">3.2.</span> <span class="nav-text">B.死锁的处理方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）鸵鸟策略"><span class="nav-number">3.2.1.</span> <span class="nav-text">（1）鸵鸟策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）死锁检测与死锁恢复"><span class="nav-number">3.2.2.</span> <span class="nav-text">（2）死锁检测与死锁恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-每种类型一个资源的死锁检测"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">A.每种类型一个资源的死锁检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-每种类型多个资源的死锁检测"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">B.每种类型多个资源的死锁检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-死锁恢复"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">C.死锁恢复</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）死锁预防"><span class="nav-number">3.2.3.</span> <span class="nav-text">（3）死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）死锁避免"><span class="nav-number">3.2.4.</span> <span class="nav-text">（4）死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-安全状态"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">A.安全状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-单个资源的银行家算法"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">B.单个资源的银行家算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-多个资源的银行家算法"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">C.多个资源的银行家算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-内存管理"><span class="nav-number">4.</span> <span class="nav-text">4.内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-虚拟内存"><span class="nav-number">4.1.</span> <span class="nav-text">A.虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-分页系统地址映射"><span class="nav-number">4.2.</span> <span class="nav-text">B.分页系统地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-页面置换算法"><span class="nav-number">4.3.</span> <span class="nav-text">C.页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）最佳置换算法-OPT-Optimal-replacement-algorithm"><span class="nav-number">4.3.1.</span> <span class="nav-text">（1）最佳置换算法(OPT, Optimal replacement algorithm)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）最近最久未使用算法-LRU-Least-Recently-Used"><span class="nav-number">4.3.2.</span> <span class="nav-text">（2）最近最久未使用算法(LRU, Least Recently Used)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）最近未使用算法-NRU-Not-Recently-Used"><span class="nav-number">4.3.3.</span> <span class="nav-text">（3）最近未使用算法(NRU, Not Recently Used)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）先进先出置换算法-FIFO-First-In-First-Out"><span class="nav-number">4.3.4.</span> <span class="nav-text">（4）先进先出置换算法(FIFO, First In First Out)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）第二次机会算法"><span class="nav-number">4.3.5.</span> <span class="nav-text">（5）第二次机会算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（6）clock置换算法"><span class="nav-number">4.3.6.</span> <span class="nav-text">（6）clock置换算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-分段"><span class="nav-number">4.4.</span> <span class="nav-text">D.分段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）概述"><span class="nav-number">4.4.1.</span> <span class="nav-text">（1）概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）分段的作用"><span class="nav-number">4.4.2.</span> <span class="nav-text">（2）分段的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E-段页式"><span class="nav-number">4.5.</span> <span class="nav-text">E.段页式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#F-分页与分段的比较"><span class="nav-number">4.6.</span> <span class="nav-text">F.分页与分段的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-设备管理"><span class="nav-number">5.</span> <span class="nav-text">5.设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-磁盘调度算法"><span class="nav-number">5.1.</span> <span class="nav-text">A.磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）先来先服务-FCFS-First-Come-First-Served"><span class="nav-number">5.1.1.</span> <span class="nav-text">（1）先来先服务(FCFS, First Come First Served)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）最短寻道时间优先-SSTF-Shortest-Seek-Time-First"><span class="nav-number">5.1.2.</span> <span class="nav-text">（2）最短寻道时间优先(SSTF, Shortest Seek Time First)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）电梯算法-SCAN"><span class="nav-number">5.1.3.</span> <span class="nav-text">（3）电梯算法(SCAN)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-链接"><span class="nav-number">6.</span> <span class="nav-text">6.链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-编译系统"><span class="nav-number">6.1.</span> <span class="nav-text">A.编译系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-静态链接"><span class="nav-number">6.2.</span> <span class="nav-text">B.静态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-目标文件"><span class="nav-number">6.3.</span> <span class="nav-text">C.目标文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-动态链接"><span class="nav-number">6.4.</span> <span class="nav-text">D.动态链接</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ayesawyer</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>  访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("yWdQWaFa2z2MWDKsMNEzvv3E-gzGzoHsz", "e6INbOXP7UPpJUnKlgxhNb52");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/nico.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
